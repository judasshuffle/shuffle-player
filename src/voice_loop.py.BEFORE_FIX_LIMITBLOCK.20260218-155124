#!/usr/bin/env python3
"""
Raspberry Pi 5 Offline Voice Jukebox - voice_loop.py

- Records short voice clips using arecord (Pulse/PipeWire compatible)
- Transcribes using faster-whisper
- Parses natural voice commands
- Controls MPV via IPC socket (/tmp/radio_mpv.sock)
- Builds playlists from SQLite DB (/home/dan/jukebox.db)
- Starts/stops streaming via start_stream.sh / stop_stream.sh

Designed to be robust:
- Schema-tolerant SQLite introspection (finds usable columns/tables)
- Genre filtering only if possible from DB (won't crash if absent)
- Safe command whitelist; no arbitrary shell execution
"""

from __future__ import annotations

import json
import os
import re
import shlex
import signal
import socket
import sqlite3
import subprocess
import sys
import tempfile
import time
import wave
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional, Sequence, Tuple

# ----------------------------
# Config (env-overridable)
# ----------------------------

DB_PATH = os.getenv("JUKEBOX_DB", "/home/dan/jukebox.db")
MPV_SOCKET = os.getenv("MPV_IPC_SOCKET", "/tmp/radio_mpv.sock")

START_STREAM_SH = os.getenv("START_STREAM_SH", "/home/dan/start_stream.sh")
STOP_STREAM_SH = os.getenv("STOP_STREAM_SH", "/home/dan/stop_stream.sh")

# Recording
ARECORD_DEVICE = os.getenv("ARECORD_DEVICE", "default")
SAMPLE_RATE = int(os.getenv("VOICE_SAMPLE_RATE", "16000"))
CHANNELS = int(os.getenv("VOICE_CHANNELS", "1"))
MAX_RECORD_SECONDS = float(os.getenv("VOICE_MAX_SECONDS", "4.5"))
SILENCE_RMS_THRESHOLD = float(os.getenv("VOICE_SILENCE_RMS", "180.0"))  # tune if needed

# Whisper
WHISPER_MODEL = os.getenv("WHISPER_MODEL", "small.en")
WHISPER_DEVICE = os.getenv("WHISPER_DEVICE", "cpu")  # cpu on Pi
WHISPER_COMPUTE_TYPE = os.getenv("WHISPER_COMPUTE_TYPE", "int8")  # good on Pi

# Playlist building
DEFAULT_LIMIT = int(os.getenv("JUKEBOX_DEFAULT_LIMIT", "80"))
MAX_LIMIT = int(os.getenv("JUKEBOX_MAX_LIMIT", "300"))
SIMILAR_YEAR_WINDOW = int(os.getenv("JUKEBOX_SIMILAR_YEAR_WINDOW", "2"))  # ± years
ARTIST_CACHE_REFRESH_SECONDS = int(os.getenv("JUKEBOX_ARTIST_REFRESH", "900"))

# Volume
VOLUME_STEP = int(os.getenv("JUKEBOX_VOLUME_STEP", "5"))
VOLUME_MIN = 0
VOLUME_MAX = 100

# Debug
DEBUG = os.getenv("JUKEBOX_DEBUG", "0").strip() in ("1", "true", "yes", "on")


# ----------------------------
# Utilities
# ----------------------------

def log(msg: str) -> None:
    ts = time.strftime("%H:%M:%S")
    print(f"[{ts}] {msg}", flush=True)

def dlog(msg: str) -> None:
    if DEBUG:
        log(f"DEBUG: {msg}")

def clamp(n: int, lo: int, hi: int) -> int:
    return max(lo, min(hi, n))

def safe_int(s: str, default: Optional[int] = None) -> Optional[int]:
    try:
        return int(s)
    except Exception:
        return default

def normalize_text(t: str) -> str:
    t = t.strip().lower()
    # keep digits/letters/spaces, drop most punctuation
    t = re.sub(r"[^a-z0-9\s']", " ", t)
    t = re.sub(r"\s+", " ", t).strip()
    return t

def parse_decade_text(text: str) -> Optional[int]:
    """
    Accepts: "70s", "1970s", "seventies", "80s", "1990s", "two thousands", etc.
    Returns decade start year (e.g., 1970, 1980, 1990, 2000, 2010).
    """
    t = normalize_text(text)

    # explicit forms like 70s/1970s/1990s
    m = re.search(r"\b(18|19|20)\d0s\b", t)
    if m:
        return int(m.group(0)[:4])
    # 2-digit decade forms like 70s, 80s, 80's, 00s, 10s
    m = re.search(r"\b(\d{2})\s*'?s\b", t)
    if m:
        d2 = int(m.group(1))
        # interpret 00-29 as 2000s (00s..20s), else 1900s (30s..90s)
        if d2 <= 29:
            return 2000 + d2
        return 1900 + d2



    word_map = {
        "sixties": 1960,
        "seventies": 1970,
        "eighties": 1980,
        "nineties": 1990,
        "two thousands": 2000,
        "two thousand": 2000,
        "noughties": 2000,
        "tens": 2010,
        "twenty tens": 2010,
        "twenties": 2020,
    }
    for k, v in word_map.items():
        if re.search(rf"\b{k}\b", t):
            return v

    return None

def extract_year(text: str) -> Optional[int]:
    t = normalize_text(text)
    m = re.search(r"\b(19\d{2}|20\d{2}|18\d{2})\b", t)
    if not m:
        return None
    y = int(m.group(1))
    if 1850 <= y <= 2099:
        return y
    return None

def words_to_number_0_100(text: str) -> Optional[int]:
    """
    Very small words-to-number helper for volume:
    handles "zero".."nineteen", "twenty".."ninety", optional "five", "percent".
    Also accepts digits already in text.
    """
    t = normalize_text(text)
    m = re.search(r"\b(\d{1,3})\b", t)
    if m:
        n = int(m.group(1))
        if 0 <= n <= 100:
            return n

    ones = {
        "zero": 0, "one": 1, "two": 2, "three": 3, "four": 4, "five": 5,
        "six": 6, "seven": 7, "eight": 8, "nine": 9, "ten": 10,
        "eleven": 11, "twelve": 12, "thirteen": 13, "fourteen": 14, "fifteen": 15,
        "sixteen": 16, "seventeen": 17, "eighteen": 18, "nineteen": 19,
    }
    tens = {
        "twenty": 20, "thirty": 30, "forty": 40, "fifty": 50,
        "sixty": 60, "seventy": 70, "eighty": 80, "ninety": 90,
        "hundred": 100,
    }

    tokens = t.split()
    total = 0
    used = False

    for i, tok in enumerate(tokens):
        if tok in ones:
            total += ones[tok]
            used = True
        elif tok in tens:
            if tok == "hundred":
                total = 100
            else:
                total += tens[tok]
            used = True

    if used and 0 <= total <= 100:
        return total
    return None


# ----------------------------
# MPV IPC client
# ----------------------------

class MPVClient:
    def __init__(self, sock_path: str) -> None:
        self.sock_path = sock_path

    def _send(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        data = (json.dumps(payload) + "\n").encode("utf-8")
        dlog(f"MPV send: {payload}")

        try:
            with socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) as s:
                s.settimeout(2.0)
                s.connect(self.sock_path)
                s.sendall(data)

                # read one JSON response line (mpv replies per request_id)
                buf = b""
                while b"\n" not in buf:
                    chunk = s.recv(4096)
                    if not chunk:
                        break
                    buf += chunk

            line = buf.split(b"\n", 1)[0].decode("utf-8", errors="replace").strip()
            if not line:
                return {"error": "empty_response"}
            resp = json.loads(line)
            dlog(f"MPV resp: {resp}")
            return resp
        except FileNotFoundError:
            return {"error": "mpv_socket_missing"}
        except (socket.timeout, ConnectionError) as e:
            return {"error": f"mpv_ipc_error: {e}"}
        except json.JSONDecodeError:
            return {"error": "mpv_bad_json_response"}
        except Exception as e:
            return {"error": f"mpv_unexpected: {e}"}

    def command(self, *args: Any) -> Dict[str, Any]:
        return self._send({"command": list(args)})

    def get_property(self, prop: str) -> Optional[Any]:
        resp = self._send({"command": ["get_property", prop]})
        if resp.get("error") == "success":
            return resp.get("data")
        return None

    def set_property(self, prop: str, value: Any) -> bool:
        resp = self._send({"command": ["set_property", prop, value]})
        return resp.get("error") == "success"

    # High-level helpers
    def pause(self) -> None:
        self.set_property("pause", True)

    def resume(self) -> None:
        self.set_property("pause", False)

    def next_track(self) -> None:
        self.command("playlist-next", "force")

    def stop_and_clear(self) -> None:
        self.command("stop")
        self.command("playlist-clear")

    def set_volume(self, vol: int) -> None:
        self.set_property("volume", clamp(vol, VOLUME_MIN, VOLUME_MAX))

    def adjust_volume(self, delta: int) -> int:
        cur = self.get_property("volume")
        try:
            cur_i = int(float(cur)) if cur is not None else 50
        except Exception:
            cur_i = 50
        newv = clamp(cur_i + delta, VOLUME_MIN, VOLUME_MAX)
        self.set_volume(newv)
        return newv

    def load_playlist(self, paths: Sequence[str], clear_first: bool = True) -> bool:
        if clear_first:
            self.command("playlist-clear")

        ok_any = False
        for i, p in enumerate(paths):
            if not p:
                continue
            # ensure exists (avoid mpv spam)
            if not Path(p).exists():
                dlog(f"Missing path skipped: {p}")
                continue
            mode = "replace" if (i == 0 and not clear_first) else "append"
            # if we cleared first, use "append" for all and then start playing
            resp = self.command("loadfile", p, "append")
            if resp.get("error") == "success":
                ok_any = True

        if ok_any:
            self.set_property("pause", False)
            # ensure playback starts from first item
            self.command("playlist-play-index", 0)
        return ok_any


# ----------------------------
# SQLite library / schema-tolerant querying
# ----------------------------

@dataclass
class TrackRow:
    path: str
    artist: Optional[str] = None
    title: Optional[str] = None
    album: Optional[str] = None
    year: Optional[int] = None
    decade: Optional[int] = None
    genre: Optional[str] = None


class LibraryDB:
    def __init__(self, db_path: str) -> None:
        self.db_path = db_path
        self._conn: Optional[sqlite3.Connection] = None
        self.table: Optional[str] = None
        self.cols: Dict[str, str] = {}  # logical -> real col name
        self._artist_cache: Tuple[float, List[str]] = (0.0, [])

    def connect(self) -> sqlite3.Connection:
        if self._conn is None:
            conn = sqlite3.connect(self.db_path, timeout=5.0)
            conn.row_factory = sqlite3.Row
            self._conn = conn
        return self._conn

    def close(self) -> None:
        if self._conn is not None:
            self._conn.close()
            self._conn = None

    def _list_tables(self) -> List[str]:
        conn = self.connect()
        rows = conn.execute(
            "SELECT name FROM sqlite_master WHERE type IN ('table','view') AND name NOT LIKE 'sqlite_%'"
        ).fetchall()
        return [r["name"] for r in rows]

    def _table_info(self, table: str) -> List[Tuple[str, str]]:
        conn = self.connect()
        rows = conn.execute(f"PRAGMA table_info({table})").fetchall()
        return [(r["name"], (r["type"] or "").lower()) for r in rows]

    def _score_table(self, cols: List[str]) -> int:
        # higher score if it looks like a track table
        want = ["path", "filepath", "file_path", "uri", "artist", "title", "album", "year", "date", "decade", "genre"]
        score = 0
        for w in want:
            if w in cols:
                score += 2
        # strongly prefer a path field
        if any(c in cols for c in ("path", "filepath", "file_path", "uri")):
            score += 10
        return score

    def introspect(self) -> None:
        tables = self._list_tables()
        if not tables:
            raise RuntimeError("No tables/views found in SQLite DB.")

        best = None
        best_score = -1
        best_cols: List[str] = []
        for t in tables:
            cols = [c for c, _ in self._table_info(t)]
            s = self._score_table([c.lower() for c in cols])
            dlog(f"Table {t} score={s} cols={cols}")
            if s > best_score:
                best = t
                best_score = s
                best_cols = cols

        if not best:
            raise RuntimeError("Could not identify a usable tracks table/view in DB.")
        self.table = best

        # Map logical names to real columns (case-insensitive)
        lower_to_real = {c.lower(): c for c in best_cols}

        def pick(*names: str) -> Optional[str]:
            for n in names:
                if n in lower_to_real:
                    return lower_to_real[n]
            return None

        self.cols = {}
        path_col = pick("path", "filepath", "file_path", "uri")
        if not path_col:
            raise RuntimeError(f"Tracks table '{best}' has no path column.")

        self.cols["path"] = path_col
        a = pick("artist", "albumartist", "album_artist", "artist_name")
        if a:
            self.cols["artist"] = a
        ti = pick("title", "track", "track_title", "name")
        if ti:
            self.cols["title"] = ti
        al = pick("album", "release", "album_title")
        if al:
            self.cols["album"] = al
        yr = pick("year", "date", "originalyear", "original_year")
        if yr:
            self.cols["year"] = yr
        dec = pick("decade")
        if dec:
            self.cols["decade"] = dec
        ge = pick("genre", "style")
        if ge:
            self.cols["genre"] = ge

        log(f"DB: using table/view '{self.table}' with columns {self.cols}")

    def _select_clause(self) -> str:
        # Always select path plus any known columns
        parts = [f"{self.cols['path']} AS path"]
        for logical in ("artist", "title", "album", "year", "decade", "genre"):
            if logical in self.cols:
                parts.append(f"{self.cols[logical]} AS {logical}")
        return ", ".join(parts)

    def get_artists(self) -> List[str]:
        now = time.time()
        last_ts, cached = self._artist_cache
        if cached and (now - last_ts) < ARTIST_CACHE_REFRESH_SECONDS:
            return cached

        if not self.table or not self.cols:
            self.introspect()

        if "artist" not in self.cols:
            self._artist_cache = (now, [])
            return []

        conn = self.connect()
        q = f"SELECT DISTINCT {self.cols['artist']} AS artist FROM {self.table} WHERE {self.cols['artist']} IS NOT NULL AND TRIM({self.cols['artist']}) != ''"
        rows = conn.execute(q).fetchall()
        artists = sorted({(r["artist"] or "").strip() for r in rows if r["artist"]})
        self._artist_cache = (now, artists)
        dlog(f"Loaded {len(artists)} artists from DB")
        return artists

    def _build_where(
        self,
        artist: Optional[str],
        decade: Optional[int],
        year_range: Optional[Tuple[int, int]],
        genre: Optional[str],
        early_late: Optional[str],
    ) -> Tuple[str, List[Any]]:
        """
        Returns (where_sql, params)
        early_late: "early" | "late" | None
        """
        clauses: List[str] = []
        params: List[Any] = []

        # artist
        if artist and "artist" in self.cols:
            clauses.append(f"LOWER({self.cols['artist']}) = LOWER(?)")
            params.append(artist)

        # genre
        if genre:
            if "genre" in self.cols:
                clauses.append(f"LOWER({self.cols['genre']}) LIKE LOWER(?)")
                params.append(f"%{genre}%")
            else:
                # no genre support, ignore safely
                dlog("Genre requested but DB has no genre column; ignoring genre filter.")

        # decade / year logic
        if year_range and "year" in self.cols:
            clauses.append(f"CAST({self.cols['year']} AS INTEGER) BETWEEN ? AND ?")
            params.extend([year_range[0], year_range[1]])
        elif decade is not None:
            if "decade" in self.cols:
                clauses.append(f"CAST({self.cols['decade']} AS INTEGER) = ?")
                params.append(decade)
            elif "year" in self.cols:
                clauses.append(f"CAST({self.cols['year']} AS INTEGER) BETWEEN ? AND ?")
                params.extend([decade, decade + 9])

        # early/late slicing (only meaningful if we have year or decade)
        if early_late and artist and "artist" in self.cols:
            if "year" in self.cols:
                # We'll apply a sub-range computed in query stage (see get_tracks)
                pass
            elif "decade" in self.cols:
                pass

        where_sql = ""
        if clauses:
            where_sql = "WHERE " + " AND ".join(clauses)
        return where_sql, params

    def _artist_year_bounds(self, artist: str) -> Tuple[Optional[int], Optional[int], Optional[int], Optional[int]]:
        """
        Returns (min_year, max_year, min_decade, max_decade) if available.
        """
        if not self.table or not self.cols:
            self.introspect()

        conn = self.connect()
        min_year = max_year = None
        min_dec = max_dec = None

        if "artist" not in self.cols:
            return (None, None, None, None)

        if "year" in self.cols:
            q = f"""
                SELECT MIN(CAST({self.cols['year']} AS INTEGER)) AS miny,
                       MAX(CAST({self.cols['year']} AS INTEGER)) AS maxy
                FROM {self.table}
                WHERE LOWER({self.cols['artist']}) = LOWER(?) AND {self.cols['year']} IS NOT NULL
            """
            r = conn.execute(q, (artist,)).fetchone()
            if r:
                min_year = r["miny"]
                max_year = r["maxy"]

        if "decade" in self.cols:
            q = f"""
                SELECT MIN(CAST({self.cols['decade']} AS INTEGER)) AS mind,
                       MAX(CAST({self.cols['decade']} AS INTEGER)) AS maxd
                FROM {self.table}
                WHERE LOWER({self.cols['artist']}) = LOWER(?) AND {self.cols['decade']} IS NOT NULL
            """
            r = conn.execute(q, (artist,)).fetchone()
            if r:
                min_dec = r["mind"]
                max_dec = r["maxd"]

        return (min_year, max_year, min_dec, max_dec)

    def get_tracks(
        self,
        artist: Optional[str] = None,
        decade: Optional[int] = None,
        year_range: Optional[Tuple[int, int]] = None,
        genre: Optional[str] = None,
        similar_year: Optional[int] = None,
        early_late: Optional[str] = None,  # "early" | "late" | None
        limit: int = DEFAULT_LIMIT,
    ) -> List[TrackRow]:
        if not self.table or not self.cols:
            self.introspect()

        limit = clamp(limit, 1, MAX_LIMIT)

        # Similar-year expands into year_range (preferred) or decade fallback
        if similar_year is not None:
            if "year" in self.cols:
                year_range = (similar_year - SIMILAR_YEAR_WINDOW, similar_year + SIMILAR_YEAR_WINDOW)
            else:
                decade = (similar_year // 10) * 10

        # Early/late expands into a sub year_range/decade_range *when artist is present*
        if early_late and artist:
            miny, maxy, mind, maxd = self._artist_year_bounds(artist)
            if miny is not None and maxy is not None and "year" in self.cols:
                span = maxy - miny
                if span <= 0:
                    # one-year artist, nothing to slice
                    pass
                else:
                    third = max(1, span // 3)
                    if early_late == "early":
                        year_range = (miny, miny + third)
                    else:
                        year_range = (maxy - third, maxy)
            elif mind is not None and maxd is not None and "decade" in self.cols:
                # decades are spaced by 10
                decs = list(range(mind, maxd + 1, 10)) if maxd >= mind else [mind]
                if len(decs) >= 3:
                    cut = max(1, len(decs) // 3)
                    if early_late == "early":
                        decade = decs[0]
                    else:
                        decade = decs[-1]
                elif decs:
                    decade = decs[0] if early_late == "early" else decs[-1]

        where_sql, params = self._build_where(artist, decade, year_range, genre, early_late)

        # Random ordering: sqlite RANDOM()
        q = f"""
            SELECT {self._select_clause()}
            FROM {self.table}
            {where_sql}
            ORDER BY RANDOM()
            LIMIT ?
        """
        params2 = params + [limit]

        conn = self.connect()
        dlog(f"SQL: {q.strip()} params={params2}")
        rows = conn.execute(q, params2).fetchall()

        out: List[TrackRow] = []
        for r in rows:
            path = (r["path"] if "path" in r.keys() else None)  # type: ignore
            if not path:
                continue
            tr = TrackRow(
                path=str(path),
                artist=(r["artist"] if "artist" in r.keys() else None),  # type: ignore
                title=(r["title"] if "title" in r.keys() else None),  # type: ignore
                album=(r["album"] if "album" in r.keys() else None),  # type: ignore
                year=safe_int(str(r["year"])) if "year" in r.keys() and r["year"] is not None else None,  # type: ignore
                decade=safe_int(str(r["decade"])) if "decade" in r.keys() and r["decade"] is not None else None,  # type: ignore
                genre=(r["genre"] if "genre" in r.keys() else None),  # type: ignore
            )
            out.append(tr)
        return out


# ----------------------------
# Voice capture (arecord) + RMS gate
# ----------------------------

def wav_rms(path: str) -> float:
    try:
        with wave.open(path, "rb") as wf:
            nchan = wf.getnchannels()
            sampw = wf.getsampwidth()
            nframes = wf.getnframes()
            if sampw != 2:
                # only support 16-bit for RMS gate
                return 0.0
            raw = wf.readframes(nframes)
            if not raw:
                return 0.0
            # little-endian int16
            import array
            a = array.array("h")
            a.frombytes(raw)
            if nchan > 1:
                # downmix by taking every nchan'th sample (cheap)
                a = array.array("h", a[::nchan])
            # RMS
            ss = 0.0
            for v in a:
                ss += float(v) * float(v)
            mean = ss / max(1, len(a))
            return mean ** 0.5
    except Exception:
        return 0.0

def record_clip(out_wav: str) -> bool:
    """
    Records a short wav clip using arecord.
    Returns True if recorded, False otherwise.
    """
    duration_s = max(1, int(round(MAX_RECORD_SECONDS)))
    cmd = [
        "arecord",
        "-D", ARECORD_DEVICE,
        "-f", "S16_LE",
        "-r", str(SAMPLE_RATE),
        "-c", str(CHANNELS),
        "-d", str(duration_s),
        "-q",
        out_wav,
    ]
    dlog(f"Recording: {' '.join(shlex.quote(c) for c in cmd)}")
    try:
        res = subprocess.run(cmd, check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return res.returncode == 0 and Path(out_wav).exists()
    except FileNotFoundError:
        log("ERROR: arecord not found. Install alsa-utils.")
        return False


# ----------------------------
# Command parsing
# ----------------------------

@dataclass
class ParsedCommand:
    intent: str  # control intent or "play"
    # play filters
    artist: Optional[str] = None
    decade: Optional[int] = None
    genre: Optional[str] = None
    similar_year: Optional[int] = None
    year_range: Optional[Tuple[int, int]] = None
    early_late: Optional[str] = None  # "early" | "late" | None
    limit: int = DEFAULT_LIMIT

    # volume params
    volume_set: Optional[int] = None
    volume_delta: Optional[int] = None


CONTROL_INTENTS = {
    "skip",
    "pause",
    "resume",
    "stop",
    "status",
    "help",
    "start_stream",
    "stop_stream",
    "stream_status",
    "volume_set",
    "volume_up",
    "volume_down",
    "mute",
    "unmute",
    "quit",
}

def best_match_artist(transcript: str, artists: List[str]) -> Optional[str]:
    """
    Attempts to identify the intended artist from transcript using:
    1) exact/contains match
    2) token overlap scoring
    """
    if not artists:
        return None

    t = normalize_text(transcript)
    if not t:
        return None

    # quick contains: pick the longest artist name contained in transcript
    contained = [a for a in artists if normalize_text(a) and normalize_text(a) in t]
    if contained:
        contained.sort(key=lambda x: len(x), reverse=True)
        return contained[0]

    # token overlap scoring
    t_tokens = set(t.split())
    best = None
    best_score = 0.0
    for a in artists:
        an = normalize_text(a)
        if not an:
            continue
        a_tokens = set(an.split())
        if not a_tokens:
            continue
        overlap = len(t_tokens & a_tokens)
        if overlap == 0:
            continue
        score = overlap / max(1, len(a_tokens))
        # slight bias towards longer names when tied
        score += min(0.15, len(an) / 200.0)
        if score > best_score:
            best_score = score
            best = a

    if best_score >= 0.60:
        return best
    return None

def extract_genre(transcript: str) -> Optional[str]:
    """
    Lightweight genre extraction:
    - "genre jazz"
    - "play jazz"
    - "shuffle metal"
    Only returns a word/short phrase after 'genre' if present,
    otherwise tries to infer when the first word is a common genre prompt.
    """
    t = normalize_text(transcript)
    m = re.search(r"\bgenre\s+([a-z0-9 ]{2,30})\b", t)
    if m:
        g = m.group(1).strip()
        # clip if it contains other keywords
        g = re.split(r"\b(artist|decade|years|year|early|late|around|like)\b", g)[0].strip()
        return g if g else None
    return None

def parse_intent(transcript: str, artists: List[str]) -> ParsedCommand:
    t = normalize_text(transcript)

    # Quit
    if re.search(r"\b(quit|exit|shutdown voice|stop listening)\b", t):
        return ParsedCommand(intent="quit")

    # Help
    if re.search(r"\b(help|commands|what can i say)\b", t):
        return ParsedCommand(intent="help")

    # Status
    if re.search(r"\b(what's playing|whats playing|now playing|status)\b", t):
        return ParsedCommand(intent="status")

    # Stream control
    if re.search(r"\b(start stream|go live|start broadcasting)\b", t):
        return ParsedCommand(intent="start_stream")
    if re.search(r"\b(stop stream|end stream|stop broadcasting)\b", t):
        return ParsedCommand(intent="stop_stream")
    if re.search(r"\b(stream status|is it streaming)\b", t):
        return ParsedCommand(intent="stream_status")

    # Playback control
    if re.search(r"\b(skip|next( track| song)?|forward|skip song)\b", t):
        return ParsedCommand(intent="skip")
    if re.search(r"\b(pause|hold on|stop a sec)\b", t):
        return ParsedCommand(intent="pause")
    if re.search(r"\b(resume|continue|unpause)\b", t) or (t == "play"):
        return ParsedCommand(intent="resume")
    if re.search(r"\b(stop music|stop playback|clear queue|silence)\b", t):
        return ParsedCommand(intent="stop")

    # Volume
    if re.search(r"\b(mute)\b", t):
        return ParsedCommand(intent="mute")
    if re.search(r"\b(unmute)\b", t):
        return ParsedCommand(intent="unmute")

    if re.search(r"\b(volume up|turn it up|louder)\b", t):
        return ParsedCommand(intent="volume_up", volume_delta=+VOLUME_STEP)
    if re.search(r"\b(volume down|turn it down|quieter)\b", t):
        return ParsedCommand(intent="volume_down", volume_delta=-VOLUME_STEP)
    if re.search(r"\b(set volume|volume to|volume)\b", t):
        n = words_to_number_0_100(t)
        if n is not None:
            return ParsedCommand(intent="volume_set", volume_set=n)

        # Otherwise: only treat as "play" if the user actually asked to play something.
    play_triggers = (
        "play", "shuffle", "random", "music",
        "artist", "by", "genre",
        "early", "late",
        "like", "around", "near"
    )

    has_decade = parse_decade_text(t) is not None
    has_year = extract_year(t) is not None
    has_trigger = any(re.search(rf"\b{re.escape(w)}\b", t) for w in play_triggers) or has_decade or has_year

    if not has_trigger:
        # Ignore unrelated speech so we don't constantly reload playlists.
        return ParsedCommand(intent="ignore")

    cmd = ParsedCommand(intent="play")


    # early/late
    if re.search(r"\b(early|old|first)\b", t):
        cmd.early_late = "early"
    if re.search(r"\b(late|later|new|recent)\b", t):
        cmd.early_late = "late"

    # similar-year
    if re.search(r"\b(like|around|near|something like)\b", t):
        y = extract_year(t)
        if y is not None:
            cmd.similar_year = y

    # decade
    dec = parse_decade_text(t)
    if dec is not None:
        cmd.decade = dec

    # genre (best-effort)
    cmd.genre = extract_genre(t)

    # artist
    # Only try to match an artist when the user clearly intends it.
    # This prevents accidental matches like "U2" from noise / "you too" / filler words.
    explicit_artist = bool(re.search(r"\b(artist|by)\b", t)) or t.startswith("play ") or t.startswith("shuffle ")

    # If it's just "shuffle" (or very short), don't guess an artist.
    if t in ("shuffle", "play", "music", "random"):
        explicit_artist = False

    if explicit_artist:
        artist = best_match_artist(t, artists)
        # Avoid accidental ultra-short artist matches unless explicitly requested.
        if artist and len(artist.strip()) >= 3:
           cmd.artist = artist


    # If the user just said a year (no "like/around"), treat as decade or exact year window
    if cmd.similar_year is None:
        y = extract_year(t)
        if y is not None:
            # if we have explicit year, treat as similar-year window (feels natural)
            cmd.similar_year = y
    # If the user just said a year (no "like/around"), treat as decade or exact year window
    if cmd.similar_year is None:
        y = extract_year(t)
        if y is not None:
            cmd.similar_year = y

    # <<< INSERT GUARD HERE >>>
    # Guard: if we heard "play ..." but extracted NO filters,
    # ignore it (prevents headphone bleed from triggering shuffle-all).
    # Allow explicit shuffle/music requests.
    if not any([
        cmd.artist,
        cmd.genre,
        cmd.early_late,
        cmd.decade is not None,
        cmd.similar_year is not None,
    ]):
        if re.search(r"\b(shuffle|random|play music|some music)\b", t) or t in ("shuffle", "random", "music"):
            pass  # allow shuffle-all
        else:
            return ParsedCommand(intent="ignore")

    # limit (optional)
    m = re.search(...)

    # limit (optional)
    m = re.search(r"\b(\d{1,3})\s+(songs|tracks)\b", t)
    if m:
        lim = safe_int(m.group(1), DEFAULT_LIMIT)
        if lim is not None:
            cmd.limit = clamp(lim, 1, MAX_LIMIT)

    return cmd


# ----------------------------
# Stream scripts
# ----------------------------

def run_script(path: str) -> bool:
    p = Path(path)
    if not p.exists():
        log(f"ERROR: script missing: {path}")
        return False
    if not os.access(path, os.X_OK):
        log(f"ERROR: script not executable: {path}")
        return False

    try:
        res = subprocess.run([path], check=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        if res.returncode != 0:
            log(f"Script failed ({path}): {res.stderr.strip() or res.stdout.strip()}")
            return False
        out = (res.stdout.strip() or "").strip()
        if out:
            log(out)
        return True
    except Exception as e:
        log(f"ERROR running script {path}: {e}")
        return False


# ----------------------------
# Whisper transcription
# ----------------------------

class WhisperTranscriber:
    def __init__(self) -> None:
        self.model = None

    def load(self) -> None:
        from faster_whisper import WhisperModel  # type: ignore
        log(f"Loading whisper model: {WHISPER_MODEL} ({WHISPER_DEVICE}/{WHISPER_COMPUTE_TYPE})")
        self.model = WhisperModel(
            WHISPER_MODEL,
            device=WHISPER_DEVICE,
            compute_type=WHISPER_COMPUTE_TYPE,
        )
        log("Whisper ready.")

    def transcribe(self, wav_path: str) -> str:
        if self.model is None:
            self.load()

        # faster-whisper returns segments generator + info
        segments, info = self.model.transcribe(
            wav_path,
            language="en",
            vad_filter=True,
            beam_size=1,
        )
        text_parts: List[str] = []
        for seg in segments:
            if seg.text:
                text_parts.append(seg.text.strip())
        out = " ".join(text_parts).strip()
        dlog(f"Transcript (lang={getattr(info, 'language', None)}): {out}")
        return out


# ----------------------------
# Action dispatcher
# ----------------------------

class VoiceJukebox:


    def handle(self, cmd) -> None:
        """Dispatch a ParsedCommand to the right handler."""
        if cmd is None:
            return
        if getattr(cmd, "intent", None) in (
            "skip", "pause", "resume", "stop", "status",
            "mute", "unmute", "volume_up", "volume_down", "volume_set",
        ):
            return self._handle_control(cmd)
        if getattr(cmd, "intent", None) == "play":
            return self._handle_play(cmd)
        return

    def __init__(self) -> None:
        self.db = LibraryDB(DB_PATH)
        self.mpv = MPVClient(MPV_SOCKET)
        self.whisper = WhisperTranscriber()
        self._running = True

        # warm-up db introspection
        if not Path(DB_PATH).exists():
            raise FileNotFoundError(f"SQLite DB not found at: {DB_PATH}")
        self.db.introspect()

        # cache artists early (non-fatal if missing)
        try:
            self.db.get_artists()
        except Exception as e:
            log(f"DB artist cache warning: {e}")

    def stop(self) -> None:
        self._running = False

    def _handle_control(self, cmd: ParsedCommand) -> None:
        if cmd.intent == "skip":
            log("Skipping…")
            self.mpv.next_track()
            return

        if cmd.intent == "pause":
            log("Paused.")
            self.mpv.pause()
            return

        if cmd.intent == "resume":
            log("Resumed.")
            self.mpv.resume()
            return

        if cmd.intent == "stop":
            log("Stopping playback and clearing queue.")
            self.mpv.stop_and_clear()
            return

        if cmd.intent == "status":
            title = self.mpv.get_property("media-title")
            artist = self.mpv.get_property("metadata/by-key/Artist")
            if title or artist:
                log(f"Now playing: {artist + ' - ' if artist else ''}{title or ''}".strip())
            else:
                log("Status: (couldn’t read now playing — but MPV IPC is reachable if skip works).")
            return

        if cmd.intent == "help":
            log("Say things like: 'shuffle', 'play Bowie', 'Bowie 80s', 'early Bowie', 'something like 1984',")
            log("'pause', 'resume', 'skip', 'volume up', 'set volume 40', 'start stream', 'stop stream'.")
            return

        if cmd.intent == "start_stream":
            log("Starting stream…")
            run_script(START_STREAM_SH)
            return

        if cmd.intent == "stop_stream":
            log("Stopping stream…")
            run_script(STOP_STREAM_SH)
            return

        if cmd.intent == "stream_status":
            # Best-effort: check if icecast mount is reachable locally
            # We won’t hardcode ports here; just confirm scripts exist + MP3 stream path is curl-able if configured.
            log("Stream status: (best-effort) use your start/stop buttons; or check: curl -I http://127.0.0.1:8001/stream.mp3")
            return

        if cmd.intent == "mute":
            log("Muted.")
            self.mpv.set_volume(0)
            return

        if cmd.intent == "unmute":
            log("Unmuted (50).")
            self.mpv.set_volume(50)
            return

        if cmd.intent == "volume_set":
            v = clamp(cmd.volume_set or 50, VOLUME_MIN, VOLUME_MAX)
            log(f"Volume set to {v}.")
            self.mpv.set_volume(v)
            return

        if cmd.intent in ("volume_up", "volume_down"):
            delta = cmd.volume_delta or (VOLUME_STEP if cmd.intent == "volume_up" else -VOLUME_STEP)
            newv = self.mpv.adjust_volume(delta)
            log(f"Volume: {newv}.")
            return

        if cmd.intent == "quit":
            log("Stopping voice loop.")
            self.stop()
            return

        log(f"Unhandled control intent: {cmd.intent}")

    def _handle_play(self, cmd: ParsedCommand) -> None:
        # If user said just "play" or "shuffle"
        # treat as shuffle all with no filters
        tracks = self.db.get_tracks(
            artist=cmd.artist,
            decade=cmd.decade,
            year_range=cmd.year_range,
            genre=cmd.genre,
            similar_year=cmd.similar_year,
            early_late=cmd.early_late,
            limit=cmd.limit,
        )

        if not tracks:
            desc = self._describe_filters(cmd)
            log(f"No matches for {desc}. Try fewer filters (e.g., just artist or just decade).")
            return

        paths = [t.path for t in tracks]
        desc = self._describe_filters(cmd)
        log(f"Queueing {len(paths)} tracks ({desc})…")
        ok = self.mpv.load_playlist(paths, clear_first=True)
        if not ok:
            log("Failed to load playlist into MPV (check MPV daemon + IPC socket).")

    def _describe_filters(self, cmd: ParsedCommand) -> str:
        parts = []
        if cmd.early_late:
            parts.append(cmd.early_late)
        if cmd.genre:
            parts.append(f"genre '{cmd.genre}'")
        if cmd.artist:
            parts.append(f"artist '{cmd.artist}'")
        if cmd.similar_year is not None:
            parts.append(f"around {cmd.similar_year}")
        elif cmd.decade is not None:
            parts.append(f"{cmd.decade}s")
        if not parts:
            return "shuffle all"
        return ", ".join(parts)


# ----------------------------
# Main loop
# ----------------------------

def main() -> int:
    log("Voice Jukebox starting…")
    log(f"DB: {DB_PATH}")
    log(f"MPV IPC: {MPV_SOCKET}")
    log(f"arecord device: {ARECORD_DEVICE} @ {SAMPLE_RATE}Hz ch={CHANNELS} dur={MAX_RECORD_SECONDS}s")
    if DEBUG:
        log("DEBUG enabled.")

    jukebox = VoiceJukebox()

    def _sig_handler(signum: int, frame: Any) -> None:
        log("Signal received, shutting down…")
        jukebox.stop()

    signal.signal(signal.SIGINT, _sig_handler)
    signal.signal(signal.SIGTERM, _sig_handler)

    # load whisper once up front (faster response)
    try:
        jukebox.whisper.load()
    except Exception as e:
        log(f"ERROR: whisper failed to load: {e}")
        return 2

    log("Listening. Speak a command every few seconds (short phrases work best).")
    log("Say 'help' for examples, or 'quit' to stop the voice loop.")

    last_artist_refresh = 0.0

    while True:
        if not jukebox._running:
            break

        # Refresh artist cache periodically (non-blocking-ish)
        now = time.time()
        if now - last_artist_refresh > ARTIST_CACHE_REFRESH_SECONDS:
            try:
                jukebox.db.get_artists()
            except Exception as e:
                dlog(f"Artist refresh warning: {e}")
            last_artist_refresh = now

        with tempfile.TemporaryDirectory(prefix="voiceclip_") as td:
            wav_path = str(Path(td) / "clip.wav")

            ok = record_clip(wav_path)
            if not ok:
                time.sleep(0.5)
                continue

            rms = wav_rms(wav_path)
            dlog(f"RMS={rms:.1f}")
            if rms < SILENCE_RMS_THRESHOLD:
                # Mostly silence; skip transcription
                continue

            try:
                text = jukebox.whisper.transcribe(wav_path)
            except Exception as e:
                log(f"Transcribe error: {e}")
                continue

            text_n = normalize_text(text)
            if not text_n or len(text_n) < 2:
                continue

            log(f"Heard: {text_n}")

            try:
                artists = jukebox.db.get_artists()
                cmd = parse_intent(text_n, artists)
                log(f"DEBUG CMD intent={getattr(cmd,'intent',None)} artist={getattr(cmd,'artist',None)} decade={getattr(cmd,'decade',None)} similar_year={getattr(cmd,'similar_year',None)} genre={getattr(cmd,'genre',None)} early_late={getattr(cmd,'early_late',None)} limit={getattr(cmd,'limit',None)}")
                jukebox.handle(cmd)
            except Exception as e:
                log(f"Command handling error: {e}")

    jukebox.db.close()
    log("Voice Jukebox stopped.")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
